'use strict';

/**
 *
 *
 * */

var zookeeper = require("node-zookeeper-client");
var _ = require("underscore");
var parser = require('properties-parser');
var Logger = require("@dp/logger-container");
var fs = require("fs");
const ServerEnv = require("@dp/server-env");

//先读取zk 服务器
var getZkAddress = function () {
    let serverConfig =  ServerEnv.getServerProperties();
    if(serverConfig && serverConfig.zkserver){
        return serverConfig.zkserver;
    }else{
        throw new Error("zkserver required");
    }
};


function Client(zkAddress, options) {
    this.zkOptions = _.extend({
        sessionTimeout: 30 * 1000,
        spinDelay: 1000,
        retries: 1
    }, options || {});


    this.address = zkAddress || getZkAddress();

    this._innerClient = null;

    this.initPromise = null;
    this.watcherCache = {};

}

/**
 * init client
 * @return Promise , 重复调用会返回同一个Promise
 * */
Client.prototype.init = function () {
    if (this.initPromise) {
        return this.initPromise;
    }
    return this.initPromise = this._createClient();
};


Client.prototype._createClient = function () {
    var logger = Logger("Zookeeper");
    var client = this._innerClient = zookeeper.createClient(this.address, this.zkOptions);
    var self = this;

    return new Promise(function (resolve, reject) {
        client.once("connected", function () {
            //把cache中的watcher重新添加一遍
            self._rebindWatchers();
            resolve();
        });
        client.on('connected', function () {
            logger.info('Zookeeper connection: state(connected).');
        });

        function onDisconnect(state) {
            logger.warn('Zookeeper connection: state(' + state + ').');
            client.close();
            //重新建立client
            self._createClient();
        }

        client.on('expired', function () {
            onDisconnect("expired");
        });
        //正常的连接断开 client会自己重连
        client.on('disconnected', function () {
            logger.info("Zookeeper connection disconnected");
        });
        client.on('error', function (e) {
            logger.error("Zookeeper connection Error ", e);
            client.close();
            return reject(e);
        });

        [
            'connectedReadOnly',
            'authenticationFailed'
        ].forEach(function (state) {
            client.on(state, function () {
                logger.warn('Zookeeper connection: state(%s).', state);
            });
        });

        //开始链接zk
        logger.info('Zookeeper connection: connecting...');
        client.connect();
    });
};


/**
 * 获取zk中的数据， 并且添加watcher
 * ZK每次触发watcher需要重新添加, 重连后也需要重新watch
 * @param path{String}
 * @param onData{Function} optional , watcher触发的时候触发
 * {
 *      event: {String} , 'NODE_DELETED' or 'NODE_DATA_CHANGED'
 *      data: Object    , 对应的数据,如果是delete ，则为Null
 * }
 * @param duplicate{Boolean} 为true时,不重复添加到watcherCache中
 * @return Promise  , resolve结果数据
 *
 * */
Client.prototype.getAndWatch = function (path, onData, duplicate) {
    var logger = Logger("Zookeeper");
    var self = this;
    if (duplicate !== true) {
        this._addWatcherForPath(path, onData);
    }
    return new Promise(function (resolve, reject) {
        self._innerClient.getData(
            path,
            function (event) {
                var name = event.getName();
                switch (name) {
                    case 'NODE_DELETED':
                        onData && onData({
                            event: name,
                            data: null
                        });
                        self.getAndWatch(path, onData, true);
                        break;
                    case 'NODE_CREATED':
                    case 'NODE_DATA_CHANGED':
                        self.getAndWatch(path, onData, true).then(function (data) {
                            if (onData) {
                                onData({
                                    event: name,
                                    data: data
                                });
                            }
                        });
                }
            },
            function (err, data, stat) {
                if (err || !stat) {
                    logger.info('Zookeeper Load path ' + path + ' Fail');
                    return resolve(null);
                }
                resolve(data ? data.toString() : null);
            }
        );
    });
};


/**
 * 为某个PATH新增watcher
 * */
Client.prototype._addWatcherForPath = function (path, fn) {
    if (!path || !fn) {
        return;
    }
    if (!(path in this.watcherCache)) {
        this.watcherCache[path] = [];
    }
    this.watcherCache[path].push(fn);
};

/**
 * 重新绑定watchers
 * */
Client.prototype._rebindWatchers = function () {
    Object.keys(this.watcherCache).forEach(path => {
        let watchers = this.watcherCache[path];
        watchers.forEach(watcher => {
            this.getAndWatch(path, watcher, true);
        });
    });
};

Client.prototype.getData = function (path) {
    var logger = Logger("Zookeeper");
    var self = this;
    return new Promise(function (resolve, reject) {
        self._innerClient.getData(
            path,
            function (err, data, stat) {
                if (err || !stat) {
                    logger.info('Zookeeper Load path ' + path + ' Fail');
                    return resolve(null);
                }
                resolve(data ? data.toString() : null);
            }
        );
    });
};

Client.prototype.getClient = function () {
    return this._innerClient;
};

module.exports = Client;