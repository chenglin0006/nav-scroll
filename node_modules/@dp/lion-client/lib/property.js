'use strict';

const zk = require("./zk");
const co = require("co");
const MAX_LISTENER_LENGTH = 20;
var cache = {};
var promiseCache = {};
var listenerCache = {};
var ServerProps = require("@dp/server-env").getServerProperties();

/**
 * 获取配置值
 * @param key{String} , Lion Key
 * @param defaultValue{String} , 默认值
 *
 * @return Promise
 * */
exports.getProperty = function (key, defaultValue) {
    if (arguments.length == 1) {
        defaultValue = null;
    }

    if (key in cache) {
        return Promise.resolve(cache[key] === null ? defaultValue : cache[key]);
    }

    /**
     * 避免并发调用创建多个Promise
     * */
    if (promiseCache[key]) {
        return promiseCache[key];
    }

    return promiseCache[key] = co(function* () {
        if (!zk.isInit) {
            yield zk.init();
        }

        let swim = false;       //是否获取到泳道数据

        //存在key，从zk读取数值加入缓存
        let value = yield zk.client.getAndWatch(path(key), res => {
            if (res && res.data && !swim) {
                cache[key] = res.data;
            }
        });

        if (ServerProps.swimlane) {
            //配置了泳道 , 优先从泳道读取数据 , 如果泳道暂时没有数据, 则依然从正常路径获取,后面泳道有了数据后, 切回泳道
            let swimlaneValue = yield zk.client.getAndWatch(swimPath(key), res => {
                //从泳道拿到了值(包括新增和修改)
                if (res && res.data) {
                    swim = true;
                    cache[key] = res.data;
                }
                //泳道删除
                if (res && res.event === "NODE_DELETED") {
                    swim = false;
                }
            });

            //泳道有值
            if (swimlaneValue !== null) {
                swim = true;
                value = swimlaneValue;
            }
        }

        if (value !== null) {
            cache[key] = value;
        }

        promiseCache[key] = null;

        return value === null ? defaultValue : value;

    });
};

/**
 * 添加监听器
 * @param key{String} , 要监听的lion key
 * @param listener{Function}, 监听函数, 接收1个参数, newValue变化后的值
 * */
exports.addListener = function (key, listener) {
    if (!key || !listener) {
        return;
    }
    if (!listenerCache[key]) {
        //第一次监听,创建监听函数队列
        listenerCache[key] = [];
        //增加监听
        co(function*() {
            if (!zk.isInit) {
                yield zk.init();
            }
            yield zk.client.getAndWatch(path(key), function (res) {
                if (res && res.data != null) {
                    try {
                        listenerCache[key].forEach(listener => {
                            listener(res.data);
                        });
                    } catch (e) {

                    }
                }
            });
        });
    }

    listenerCache[key].push(listener);
    if (listenerCache[key].length > MAX_LISTENER_LENGTH) {
        require("@dp/logger-container")("Lion").warn("Lion Key [" + key + "]监听函数过多,可能会引发内存泄漏!!")
    }

};

function path(key) {
    return zk.PATH + "/" + key;
}

function swimPath(key) {
    return path(key) + "/" + ServerProps.swimlane;
}
